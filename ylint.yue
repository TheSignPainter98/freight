local *

import 'clap' as :ArgParser, :Param, :Subcommand
import 'quicktype' as :declare_type, :F, :T
import 'spec' as :run_tests, :spec

main = (args) ->
  args, ok = parse_args args
  if not ok
    return

  if args.test?
    run_tests!
  else if args.check?
    ok = check args.check
    if not ok
      os.exit 1
  os.exit 0

parse_args = F '([string]) -> <?{}, boolean>', (args) ->
  parser = with ArgParser 'ylint'
    \version '1.0'
    \description 'a very rudamentary yuescript linter'
    \add with Subcommand 'check'
      \description 'check for lint'
      \add with Param 'file'
        \description 'file to scan'
    \add with Subcommand 'test'
      \description 'run tests'
  parser\parse args

check = F '({}) -> boolean', (args) ->
  { :file } = args

  lines = io.lines file
  errs = run_checks file, lines,
    * ImportForm!
    -- * ImportStatementsSorted!
    -- * ImportItemsSorted!
  for err in *errs
    buf = {}
    err\fmt buf
    print table.concat buf
  #errs == 0

run_checks = F '(string, function, [Check]) -> [Error]', (file, src_lines, checks) ->
  line_no = 0
  for src_line in src_lines
    line_no += 1
    for check in *checks
      location = :file, row: line_no
      line = :location, content: src_line
      check\on_line? line

  for check in *checks
    new_errs = check\on_eof?!
  Declare::errs!

declare_type 'Check', [[{
  on_line: ?(Line) => <>,
  on_eof: ?() => <>,
}]]
declare_type 'Line', [[{
  location: Location,
  content: string,
}]]
declare_type 'Location', [[{
  file: string,
  row: number,
}]]

class Declare
  @errs: T '() => [Error]', => @_errs

  @_errs: T '[Error]', {}

  @error: F '(Error) => <>', (err) =>
    @_errs[] = err

class ImportForm
  on_line: F '(Line) => <>', (line) =>
    if not line.content\match '^%s*import'
      return
    if not line.content\match 'from require'
      return
    Declare::error with Error 'non-standard import form'
      \at line
      \help [[use form `import 'foo' as :bar]]

-- class ImportStatementsSorted
--   new: =>
--     @current_import_block = T '[Line]', {}
--
--   on_line: F '(Line) => <>', (line) =>
--     if line_is_empty line
--       return @on_block_end!
--     if not line\match '^%s*import'
--       return
--     @current_import_block[] = line
--     nil
--
--   on_eof: F '() => <>', (line) =>
--     @on_block_end!
--
--   on_block_end: F '() => ?Error', =>
--     @current_import_block = {}
--     nil

-- class ImportItemsSorted -- TODO(kcza): complete me!

declare_type 'Error', [[{
  fmt: ({string}) => <>,
}]]
class Error
  new: F '(string) => <>', (@message) =>
    @line = T '?Line', nil
    @_help = T '?string', nil

  at: F '(Line) => <>', (@line) =>

  help: F '(string) => <>', (@_help) =>

  fmt: F '({string}) => <>', (buf) =>
    with buf
      [] = 'warning: '
      [] = @message
      if @line?
        [] = "\n --> #{@line.location.file}:#{@line.location.row}"
        [] = '\n  |'
        [] = '\n  | '
        [] = @line.content
        [] = '\n  |'

      if @_help?
        [] = '\n'
        [] = '  * help: '
        [] = @_help
    return

line_is_empty = F '(Line) -> boolean', (line) ->
  content = line.content
  (content\match '^%s*$')? or (content\match '^%s*--.*$')?

spec ->
  import 'spec_macros' as $
  import 'spec' as :describe, :it, :matchers
  import deep_eq, eq, has_fields, len from matchers

  run_check = F '(Check, string, string) -> [Error]', (check, file, content) ->
    if '\n' != content\sub -1
      content = content .. '\n'
    lines = content\gmatch '(.-)\n'
    run_checks file, lines, {check}

  describe 'ImportForm', ->
    it 'accepts proper form', ->
      errs = run_check ImportForm!, 'test.yue', [[
        import 'asdf' as :fdas
        import "asdf" as :fdas
      ]]
      $expect_that errs, deep_eq {}

    it 'rejects improper form', ->
      file = 'test.yue'
      errs = run_check ImportForm!, file, [[
        import fdsa from require 'asdf'
      ]]
      $assert_that errs, len eq 1
      $assert_that errs[1], has_fields
        message: eq 'non-standard import form'
        location: has_fields
          file: eq file
          row: eq 1

main {...}
