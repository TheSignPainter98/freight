local *

import 'quicktype' as :declare_type, :F, :T
import 'spec' as :spec

declare_type 'SlotInfo', [[{
  count: number,
  displayName: string,
}]]

declare_type 'Stockpile', [[{
  info: () => StockpileInfo,
}]]
export class Stockpile
  new: F '([Inventory]) => <>', (@inventories) =>

  info: F '() => StockpileInfo', =>
    estimated_capacity = 0
    stored_items_by_name = {}
    for inventory in *@inventories
      estimated_capacity += inventory\gather_info stored_items_by_name

    stored_items = [ info for _, info in pairs stored_items_by_name ]
    table.sort stored_items, (a, b) ->
      a.item < b.item
    :stored_items, :estimated_capacity

declare_type 'Inventory', [[{
  gather_info: ({string->StoredItemInfo}) => number,
}]]
declare_type 'InventoryBackend', [[{
  size: () => number,
  slot_content: (number) => ?SlotInfo,
  slot_capacity: (number) => number,
}]]
export class Inventory
  new: F '(InventoryBackend) => <>', (@backend) =>

  gather_info: F '({string->StoredItemInfo}) => number', (stored_items_by_name) =>
    total_populated_capacity = 0
    total_capacity = 0
    populated_slots = 0
    with stored_items_by_name
      for i = 1, @backend\size!
        capacity = @backend\slot_capacity i
        total_capacity += capacity
        slot = @backend\slot_content i
        if not slot?
          continue
        populated_slots += 1
        total_populated_capacity += capacity

        item = slot.displayName
        [item] ??= T 'StoredItemInfo',
          :item
          stored: 0
        with [item]
          .stored += slot.count

    estimated_capacity = total_populated_capacity * @backend\size! / populated_slots
    if estimated_capacity >= total_capacity
      return total_capacity
    return estimated_capacity

declare_type 'StockpileInfo', [[{
  stored_items: [StoredItemInfo],
  estimated_capacity: number,
}]]
declare_type 'StoredItemInfo', [[{
  item: string,
  stored: number,
}]]
export class MinecraftBackend
  @find: F '() => [InventoryBackend]', =>
    inventory_peripherals = { peripheral.find 'inventory' }
    [ MinecraftBackend peripheral for peripheral in *inventory_peripherals]

  new: (@inventory) =>

  size: F '() => number', =>
    @inventory.size!

  slot_content: F '(number) => ?SlotInfo', (slot_id) =>
    @inventory.getItemDetail slot_id

  slot_capacity: F '(number) => number', (slot_id) =>
    @inventory.getItemLimit slot_id


declare_type 'TestInventoryBackendOpts', [[{
  size: ?() => number,
  slot_content: ?(number) => ?SlotInfo,
  slot_capacity: ?(number) => number,
}]]
export class TestInventoryBackend
  new: F '(?TestInventoryBackendOpts) => <>', (opts={}) =>
    {
      :size=-> error 'size unimplemented'
      :slot_content=-> error 'slot_content unimplemented'
      :slot_capacity=-> error 'slot_capacity unimplemented'
    } = opts
    @size = F '() => number', size
    @slot_content = F '(number) => ?SlotInfo', slot_content
    @slot_capacity = F '(number) => number', slot_capacity

spec ->
  import 'spec_macros' as $

  import 'spec' as :describe, :it, :matchers

  import deep_eq, eq, errors, gt, has_fields, lt, matches from matchers

  describe 'Stockpile', ->
    describe '\\info', ->
      it 'returns all info', ->
        item1 = 'Diamond Axe'
        item2 = 'Enchanting Table'
        item3 = 'Fishing Rod'
        inventory1 = Inventory TestInventoryBackend
          size: => 4
          slot_content: (slot_id) =>
            displayName = if slot_id % 2 == 1
              item1
            else
              item2
            {
              count: 16 * slot_id
              :displayName
            }
          slot_capacity: (slot_id) =>
            32 * slot_id
        inventory2 = Inventory TestInventoryBackend
          size: => 4
          slot_content: (slot_id) =>
            displayName = if slot_id % 2 == 1
              item2
            else
              item3
            {
              count: 3 + 16 * slot_id
              :displayName
            }
          slot_capacity: (slot_id) =>
            3 + 32 * slot_id
        stockpile = Stockpile
          * inventory1
          * inventory2

        info = stockpile\info!
        $expect_that info, has_fields
          estimated_capacity: eq 0 +
            32 * (1 + 3) +
            32 * (1 + 2 + 3 + 4) + 3 * 2 +
            32 * (2 + 4) + 3 * 2
          stored_items: deep_eq
            * item: item1
              stored: 16 * (1 + 3)
            * item: item2
              stored: 16 * (1 + 2 + 3 + 4) + 3 * 2
            * item: item3
              stored: 16 * (2 + 4) + 3 * 2

      it 'estimates remaining capacity', ->
        inventory = Inventory TestInventoryBackend
          size: => 3
          slot_content: (slot_id) =>
            switch slot_id
              when 1
                displayName: 'Oak Planks', count: 16
              when 2
                displayName: 'Oak Sign', count: 32
              when 3
                nil
              else
                error "internal error: unexpected slot_id: #{slot_id}"
          slot_capacity: (slot_id) =>
            switch slot_id
              when 1
                64
              when 2
                16
              when 3
                64
              else
                error "internal error: unexpected slot_id: #{slot_id}"
        stockpile = Stockpile
          * inventory

        info = stockpile\info!
        $expect_that info, has_fields
          estimated_capacity: gt 64 + 16
        $expect_that info, has_fields
          estimated_capacity: lt 64 * 3
