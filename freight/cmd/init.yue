local *

import 'clap' as :Flag, :Param, :Subcommand
import 'freight.config' as :CONFIG_FILE
import 'freight.configurator.editor' as :ABORT, :Editor
import 'freight.toml' as :parse_toml
import 'quicktype' as :F, :T
import 'spec' as :spec

display = require 'freight.nodes.display.main'
factory = require 'freight.nodes.factory.main'
ledger = require 'freight.nodes.ledger.main'
marshal = require 'freight.nodes.marshal.main'

export subcommand = with Subcommand 'init'
  \description 'initialise this freight instance'
  \add with Flag 'force'
    \description 'overwrite existing config'
  \add with Param 'instance-type'
    \description 'the type of instance to initialise'
    \options
      * 'display'
      * 'factory'
      * 'ledger'
      * 'marshal'

default_config_by_type = T '{string->()-><?string, ?string>}',
  display: display.default_config
  factory: factory.default_config
  ledger: ledger.default_config
  marshal: marshal.default_config

export main = F '({}) -> <>', (args) ->
  default_config_fn = default_config_by_type[args.instance_type]
  if not default_config_fn?
    error "internal error: unrecognised instance type '#{args.instance_type}'"

  if not args.force
    with? io.open CONFIG_FILE, 'r'
      \close!
      print "#{CONFIG_FILE} already exists"
      return

  editor = Editor!
  validator = F '(string, string) -> boolean', (text) -> validate_config text, args.instance_type
  config, err = editor\edit_text default_config_fn!, CONFIG_FILE, validator, (_) ->
    print "press [ENTER] edit #{CONFIG_FILE}, [q] to abort"
    resp = io.read '*l'
    switch resp
      when 'q'
        ABORT
      when ''
        nil

  if err != nil
    print "cannot init: #{err}"
    return

  with assert io.open CONFIG_FILE, 'w+'
    assert \write config
    assert \close!

  print "#{args.instance_type} configured"
  return

validate_config = F '(string, string) -> boolean', (raw, instance_type) ->
  local config, err
  try
    config = parse_toml raw
  catch err2
    err = err2
  if err?
    print err
    return false

  if not config[instance_type]?
    print "config does not contain #{instance_type} section"
    return false

  true

spec ->
  import 'spec_macros' as $

  import 'spec' as :describe, :it, :matchers

  import has_fields, has_type, no_errors from matchers

  configs = [:name, :raw_fn for name, raw_fn in pairs default_config_by_type]
  table.sort configs, (a, b) -> a.name < b.name

  for config in *configs
    describe "default #{config.name} config", ->
      it 'is valid toml', ->
        parsed_default_config = parse_toml config.raw_fn!

        $expect_that parsed_default_config, has_type 'table'
        $expect_that parsed_default_config, has_fields
          [config.name]: has_type 'table'
