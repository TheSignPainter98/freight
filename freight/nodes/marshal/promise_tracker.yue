local *

-- TODO(kcza): if train is lost, cancel its schedule (assuming it has the expected schedule!)

import 'freight.nodes.marshal.clock' as :MinecraftClock
import 'quicktype' as :declare_type, :F, :T
import 'spec' as :spec

declare_type 'PromiseTracker', [[{
  promise: (string, [PromiseStation], ?number, ?number) => Promise,
  break_promise: (Promise) => <>,
  train_is_promised: (string) => boolean,
  station_is_fully_promised: (string) => boolean,
  declare_train_seen: (string, string) => <>,
}]]
declare_type 'Promise', [[{
  id: number,
  train: string,
  stations: [PromiseStation],
  should_approach_index: number,
  deadline: ?number,
  max_step_duration: number
}]]
declare_type 'PromiseStation', [[{
  name: string,
  capacity: number,
}]]
declare_type 'PromiseSet', [[{
  count: number,
  promises: {number->Promise},
}]]
export class PromiseTracker
  new: F '(Random, ?Clock) => <>', (@rand, @clock=MinecraftClock!) =>
    @promises = T '{number->Promise}', {}
    @train_promises = T '{string->Promise}', {}
    @station_promise_sets = T '{string->PromiseSet}', {}
    @train_lost_promises = T '{string->Promise}', {}

  promise: F '(string, [PromiseStation], ?number, ?number) => Promise', (train, stations, max_step_duration=30*60, max_unload_duration=60) =>
    if @train_promises[train]?
      error "internal error: cannot promise already-promised train '#{train}'"

    id = @_generate_id!
    deadline = @clock\now! + max_step_duration
    promise = T 'Promise',
      :id
      :train
      :stations
      should_approach_index: 1
      :deadline
      :max_step_duration
      :max_unload_duration
    @promises[id] = promise
    @train_promises[promise.train] = promise
    for station in *stations
      promise_set = @station_promise_sets[station.name] ?? do
        promise_set =
          count: 0
          promises: {}
        @station_promise_sets[station.name] = promise_set
        promise_set
      with promise_set
        .count += 1
        .promises[id] = promise
    promise

  _generate_id: F '() => number', =>
    local id
    repeat
      id = @rand\random 2000000
    until not @promises[id]?
    id

  break_promise: F '(Promise) => <>', (promise) =>
    id = promise.id
    @promises[id] = nil
    @train_lost_promises[promise.train] = nil
    @train_promises[promise.train] = nil
    for station in *promise.stations
      with? @station_promise_sets[station.name]
        if .promises[id]?
          .count -= 1
        .promises[id] = nil

  train_is_promised: F '(string) => boolean', (train_name) =>
    @_prune!
    @train_promises[train_name]?

  train_is_lost: F '(string) => boolean', (train_name) =>
    @_prune!
    @train_lost_promises[train_name]?

  station_is_fully_promised: F '(PromiseStation) => boolean', (station) =>
    @_prune!

    promise_set = @station_promise_sets[station.name]
    if not promise_set?
      return false
    promise_set.count >= station.capacity

  promise_valid: F '(Promise) => boolean', (promise) =>
    if not promise.deadline?
      return true
    if not @promises[promise.id]?
      return false
    @clock\now! < promise.deadline

  declare_train_seen: F '(string, string) => <>', (train_name, station_name) =>
    promise = @train_promises[train_name]
    if not promise?
      return
    if @train_lost_promises[train_name]?
      return

    with promise
      switch station_name
        when .stations[.should_approach_index].name
          promise_set = @station_promise_sets[station_name]
          if promise_set.promises[.id]?
            promise_set.count -= 1
          promise_set.promises[.id] = nil

          .should_approach_index += 1

          max_duration = if .should_approach_index <= #.stations
            promise.max_step_duration
          else
            promise.max_unload_duration
          .deadline = @clock\now! + max_duration
        when .stations[.should_approach_index-1]?.name
          -- Ignore repeat observations.
        else
          @train_lost_promises[train_name] = promise

          -- Release remaining stops
          for station in *promise.stations
            promise_set = @station_promise_sets[station.name]
            if not promise_set?
              continue
            if promise_set.promises[.id]?
              promise_set.count -= 1
            promise_set.promises[.id] = nil

          -- Do not use train until manually cleared for use.
          .deadline = nil
    return

  _prune: F '() => <>', =>
    ids_to_prune = with {}
      for id, promise in pairs @promises
        if not @promise_valid promise
          [] = id

    for id in *ids_to_prune
      promise = @promises[id]

      if promise.should_approach_index > #promise.stations
        @promises[id] = nil
        @train_promises[promise.train] = nil
      else
        @train_lost_promises[promise.train] = promise

      for station in *promise.stations
        promise_set = @station_promise_sets[station.name]
        if promise_set.promises[id]?
          promise_set.count -= 1
        promise_set.promises[id] = nil

  ut_break_all_promises: F '() => <>', =>
    print 'BREAKING ALL'
    promises = [ promise for _, promise in pairs @promises ]
    for promise in *promises
      @break_promise promise

spec ->
  import 'spec_macros' as $

  import 'freight.nodes.marshal.clock' as :TestClock
  import 'freight.nodes.marshal.pseudo_random' as :PseudoRandom
  import 'spec' as :describe, :it, :matchers

  import eq from matchers

  describe 'PromiseTracker', ->
    it 'makes and breaks promises', ->
      rand = PseudoRandom 12345
      clock = TestClock!
      with PromiseTracker rand, clock
        TRAIN_NAME_1 = 'test_train_name_1'
        STATIONS_1 =
          * name: 'bank-gold-outbound'
            capacity: 1
          * name: 'tower-hill-gold-inbound'
            capacity: 2
        TRAIN_NAME_2 = 'test_train_name_2'
        STATIONS_2 =
          * name: 'canary-wharf-gold-outbound'
            capacity: 1
          * name: 'tower-hill-gold-inbound'
            capacity: 2

        promise_1 = \promise TRAIN_NAME_1, STATIONS_1
        $expect_that (\train_is_promised TRAIN_NAME_1), eq true
        for station in *STATIONS_1
          $expect_that (\station_is_fully_promised station), eq station.capacity == 1
        for station in *STATIONS_2
          $expect_that (\station_is_fully_promised station), eq false

        promise_2 = \promise TRAIN_NAME_2, STATIONS_2
        for station in *STATIONS_1
          $expect_that (\station_is_fully_promised station), eq true
        for station in *STATIONS_2
          $expect_that (\station_is_fully_promised station), eq true

        \break_promise promise_1
        for station in *STATIONS_1
          $expect_that (\station_is_fully_promised station), eq false
        for station in *STATIONS_2
          $expect_that (\station_is_fully_promised station), eq station.capacity == 1

        \break_promise promise_2
        for station in *STATIONS_1
          $expect_that (\station_is_fully_promised station), eq false
        for station in *STATIONS_2
          $expect_that (\station_is_fully_promised station), eq false

    it 'handles valid train arrival', ->
      rand = PseudoRandom 12345
      clock = TestClock!
      with PromiseTracker rand, clock
        TRAIN_NAME = 'test-train-name'
        STATIONS =
          * name: 'station-1'
            capacity: 1
          * name: 'station-2'
            capacity: 1
        MAX_STEP_DURATION = 100
        MAX_UNLOAD_DURATION = 10

        $expect_that (\train_is_promised TRAIN_NAME), eq false

        \promise TRAIN_NAME, STATIONS, MAX_STEP_DURATION, MAX_UNLOAD_DURATION
        $expect_that (\train_is_promised TRAIN_NAME), eq true
        $expect_that (\station_is_fully_promised STATIONS[1]), eq true
        $expect_that (\station_is_fully_promised STATIONS[2]), eq true
        clock.time += MAX_STEP_DURATION - 1

        \declare_train_seen TRAIN_NAME, 'station-1'
        $expect_that (\train_is_promised TRAIN_NAME), eq true
        $expect_that (\station_is_fully_promised STATIONS[1]), eq false
        $expect_that (\station_is_fully_promised STATIONS[2]), eq true
        clock.time += MAX_STEP_DURATION - 1

        \declare_train_seen TRAIN_NAME, 'station-1'
        $expect_that (\train_is_promised TRAIN_NAME), eq true
        $expect_that (\station_is_fully_promised STATIONS[1]), eq false
        $expect_that (\station_is_fully_promised STATIONS[2]), eq true
        clock.time += MAX_STEP_DURATION - 1

        \declare_train_seen TRAIN_NAME, 'station-2'
        $expect_that (\train_is_promised TRAIN_NAME), eq true
        $expect_that (\station_is_fully_promised STATIONS[1]), eq false
        $expect_that (\station_is_fully_promised STATIONS[2]), eq false

        clock.time += MAX_UNLOAD_DURATION - 1
        $expect_that (\train_is_promised TRAIN_NAME), eq true
        $expect_that (\station_is_fully_promised STATIONS[1]), eq false
        $expect_that (\station_is_fully_promised STATIONS[2]), eq false

        clock.time += 1
        $expect_that (\train_is_promised TRAIN_NAME), eq false
        $expect_that (\station_is_fully_promised STATIONS[1]), eq false
        $expect_that (\station_is_fully_promised STATIONS[2]), eq false

    it 'handles invalid train arrival', ->
      rand = PseudoRandom 12345
      clock = TestClock!
      with PromiseTracker rand, clock
        TRAIN_NAME = 'test-train-name'
        STATIONS =
          * name: 'station-1'
            capacity: 1
        MAX_STEP_DURATION = 100
        MAX_UNLOAD_DURATION = 10
        promise = \promise TRAIN_NAME, STATIONS, MAX_STEP_DURATION, MAX_UNLOAD_DURATION

        $assert_that (\station_is_fully_promised STATIONS[1]), eq true

        \declare_train_seen TRAIN_NAME, 'unrelated-station'
        $expect_that (\train_is_lost TRAIN_NAME), eq true
        $expect_that (\station_is_fully_promised STATIONS[1]), eq false

        \break_promise promise
        $expect_that (\train_is_lost TRAIN_NAME), eq false
        $expect_that (\station_is_fully_promised STATIONS[1]), eq false

    it 'handles promise expiry', ->
      rand = PseudoRandom 12345
      clock = TestClock!
      with PromiseTracker rand, clock
        TRAIN_NAME = 'test-train-name'
        STATIONS =
          * name: 'station-1'
            capacity: 1
        MAX_STEP_DURATION = 100
        MAX_UNLOAD_DURATION = 10
        promise = \promise TRAIN_NAME, STATIONS, MAX_STEP_DURATION, MAX_UNLOAD_DURATION

        $assert_that (\train_is_promised TRAIN_NAME), eq true
        $assert_that (\station_is_fully_promised STATIONS[1]), eq true
        $expect_that (\train_is_lost TRAIN_NAME), eq false

        clock.time += MAX_STEP_DURATION

        $expect_that (\train_is_promised TRAIN_NAME), eq true
        $expect_that (\station_is_fully_promised STATIONS[1]), eq false
        $expect_that (\train_is_lost TRAIN_NAME), eq true

        \break_promise promise

        $expect_that (\train_is_promised TRAIN_NAME), eq false
        $expect_that (\station_is_fully_promised STATIONS[1]), eq false

    it 'handles unseen trains', ->
      rand = PseudoRandom 12345
      clock = TestClock!
      with PromiseTracker rand, clock
        $expect_that (\train_is_promised 'spurious-train'), eq false
