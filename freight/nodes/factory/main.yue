local *
local ScheduleRequest
local ScheduleResponse
local StockpileRequest
local StockpileResponse
local InfoRequest
local InfoResponse
local FactoryHeartbeat
local TrainsPresent

import 'compat' as :HOST
import 'freight.logger' as :fatal, :log
import 'freight.pc' as :Pc
import 'freight.peripheral.station' as MinecraftBackend: MinecraftStationBackend, :Station
import 'freight.peripheral.stockpile' as :Inventory, MinecraftBackend: MinecraftInventoryBackend, :Stockpile
import 'freight.peripheral.uplink' as :IdempotenceToken, :Packet, :Uplink
import 'quicktype' as :declare_type, :F, :T
import 'spec' as :repr, :spec

export default_config = ->
  root_config = [=[
[factory]
name = '<factory-name>'
]=]
  stockpile_config = F '(string) -> string', (resource_name) -> "[[stockpile]]
name = '#{resource_name}'
# surplus_amount = 1152
# shortage_amount = 576
"
  station_config = F '(string) -> string', (station_name) -> "[[stations]]
name = '#{station_name}'
type = 'inbound' # or 'outbound'
handles = '<resource-id>'
network = 'mainline'
"
  resource_names, inventories_found = switch HOST
    when 'minecraft'
      inventories = [ Inventory backend for backend in *MinecraftInventoryBackend::find! ]
      stockpile = Stockpile inventories

      resources = [ stored_item.item for stored_item in *stockpile\info!.stored_items ]
      resources, #inventories > 0
    when 'native'
      {'test-resource'}, true
    else
      error "internal error: unknown host #{HOST}"

  station_names = switch HOST
    when 'minecraft'
      stations = [ Station backend for backend in *MinecraftStationBackend::find! ]
      seen_station_names = {}
      for station in *stations
        err = station\validate!
        if err?
          fatal err
        seen_station_names[station\name!] = true

      station_names = [ station_name for station_name, _ in pairs seen_station_names ]
      table.sort station_names
      station_names
    when 'native'
      {'test-station'}
    else
      error "internal error: unknown host #{HOST}"

  issues =
    no_stations: #station_names == 0
    no_inventories: not inventories_found
    no_resources: #resource_names == 0
  num_issues = do
    num_issues = 0
    for _, present in pairs issues
      if present
        num_issues += 1
    num_issues
  config_fragments = with {}
    if num_issues > 0
      [] = '# Issues detected! Please resolve the following:'
      [] = '#'
    if issues.no_stations
      [] = '# * No stations detected'
    if issues.no_inventories
      [] = '# * No inventories detected'
    else if issues.no_resources
      [] = '# * No resources detected in inventories'
    if num_issues > 0
      [] = '#'
      [] = '# Once resolved, run the following command to'
      [] = '# overwrite this config file:'
      [] = '#'
      -- TODO(kcza): reword once remote configuration is added
      [] = '# > freight init factory --force'

    [] = root_config
    for resource_name in *resource_names
      [] = stockpile_config resource_name
    for station_name in *station_names
      [] = station_config station_name
  table.concat config_fragments, '\n'

export main = F '(FactoryConfig) -> <>', (config) ->
  print 'starting factory'

  pc = Pc!

  stations = do
    stations = [ Station backend for backend in *MinecraftStationBackend::find! ]
    if #stations == 0
      fatal "cannot find any stations"
    stations

  stockpile = do
    inventories = [ Inventory backend for backend in *MinecraftInventoryBackend::find! ]
    if #inventories == 0
      fatal 'cannot find any inventories'
    Stockpile inventories

  with Factory config, pc, stations, stockpile, Uplink!
    \run!

declare_type 'FactoryConfig', [[{
  factory: {
    name: string,
  },
  stations: [StationConfig],
}]]
declare_type 'SurplusConfig', [[
  {name: string}
  + {surplus_amount: number}
    | {shortage_amount: number}
]]
declare_type 'StationConfig', [[{
  name: string,
  type: "inbound"|"outbound",
  handles: string,
  network: string,
}]]
class Factory
  new: F '(FactoryConfig, Pc, [Station], Stockpile, Uplink) => <>', (@config, @pc, @stations, @stockpile, @uplink) =>
    name = @name!
    if @pc\name! != name
      @pc\set_name name
    @heartbeat_num = T 'number', 0

  name: F '() => string', =>
    @config.factory.name

  run: F '() => !', =>
    @send_heartbeat!
    parallel.waitForAny @\run_steps,
      @\run_heartbeats,
      @\run_peripheral_detection,
      @\run_peripheral_detach_detection
      -- TODO(kcza): detect marshal ID, messages sent to nil marshal shall be ignored

  run_steps: F '() => !', =>
    while true
      @do_network_step!

  do_network_step: F '() => <>', =>
    from_id, message = @uplink\receive_from_any!
    if not from_id?
      return

    switch message\protocol!
      when 'StockpileRequest'
        @on_stockpile_request from_id, message
      when 'ScheduleRequest'
        @on_schedule_request from_id, message
      when 'InfoRequest'
        @on_info_request from_id, message
      else
        log -> "ignoring #{message\protocol!} message"

  on_stockpile_request: F '(number, Packet) => <>', (requester, request) =>
    log -> 'handling stockpile request'

    info = @stockpile\info!
    @uplink\send_to requester, StockpileResponse request.idemp_tok, info

  on_schedule_request: F '(number, Packet) => <>', (requester, request) =>
    log -> 'handling schedule request'

    { :idemp_tok, :station_name, :schedule } = request
    station = @get_station station_name
    if not station?
      @uplink\send_to requester, ScheduleResponse idemp_tok, "no such station: #{station_name} at #{@name!}"
      return

    station\apply_schedule schedule
    @uplink\send_to requester, ScheduleResponse idemp_tok, nil

  get_station: F '(string) => ?Station', (name) =>
    for station in *@stations
      if station\name! == name
        return station
    nil

  on_info_request: F '(number, Packet) => <>', (requester, request) =>
    log -> 'handling info request'

    stockpile_info = @stockpile\info!
    station_infos = [ station\info! for station in *@stations ]
    response = InfoResponse request.idemp_tok, @name!, station_infos, stockpile_info
    @uplink\send_to requester, response

  run_heartbeats: F '() => !', =>
    HEARTBEAT_PERIOD = 10
    while true
      @send_heartbeat!
      os.sleep HEARTBEAT_PERIOD

  run_peripheral_detection: F '() => !', =>
    while true
      os.pullEvent 'peripheral'
      @send_heartbeat!

  run_peripheral_detach_detection: F '() => !', =>
    while true
      os.pullEvent 'peripheral_detach'
      @send_heartbeat!

  send_heartbeat: F '() => <>', =>
    stations = @detect_stations!
    stockpile_info = @stockpile\info!
    heartbeat = FactoryHeartbeat @pc\id!, @name!, stations, stockpile_info

    @heartbeat_num += 1
    log -> "sending heartbeat #{@heartbeat_num}: #{repr heartbeat}"

    @uplink\broadcast heartbeat

  detect_stations: F '() => DetectedStations', =>
    -- TODO(kcza): get station detector backend to update @stations here

    detected_station_info = with {}
      for station in *@stations
        name = station\name!
        info = [name]
        if not info?
          [name] = do
            config = @get_station_config name
            known = config?
            info = :name, :known, present_trains: {}
            if known
              info = { ...config, ...info }
            info

        present_train = station\train_name!
        if present_train?
          info.present_trains[] = present_train

    with known: {}, unknown: {}
      for _, station_info in pairs detected_station_info
        known = station_info.known
        station_info.known = nil

        if known
          .known[] = station_info
        else
          .unknown[] = station_info

      table.sort .known, (a, b) -> a.name < b.name
      table.sort .unknown, (a, b) -> a.name < b.name

  get_station_config: F '(string) => ?StationConfig', (name) =>
    for station_config in *@config.stations
      if station_config.name == name
        return station_config
    nil

export class StockpileRequest extends Packet
  new: F '(IdempotenceToken) => <>', (@idemp_tok) =>

export class StockpileResponse extends Packet
  new: F '(IdempotenceToken, StockpileInfo) => <>', (@idemp_tok, @info) =>

export class ScheduleRequest extends Packet
  new: F '(IdempotenceToken, string, Schedule) => <>', (@idemp_tok, @station_name, @schedule) =>

export class ScheduleResponse extends Packet
  new: F '(IdempotenceToken, ?string) => <>', (@idemp_tok, @error_reason) =>

export class InfoRequest extends Packet
  new: F '(IdempotenceToken) => <>', (@idemp_tok) =>

export class InfoResponse extends Packet
  new: F '(IdempotenceToken, string, [StationInfo], StockpileInfo) => <>', (@idemp_tok, @name, @station_infos, @stockpile_info) =>

declare_type 'FactoryHeartbeat', [[{
  pc_id: number,
  name: string,
  stations: DetectedStations,
  stockpile: StockpileInfo,
}]]
declare_type 'DetectedStations', [[{
  known: [KnownDetectedStation],
  unknown: [UnknownDetectedStation],
}]]
declare_type 'KnownDetectedStation', 'StationConfig + DetectedTrains'
declare_type 'UnknownDetectedStation', [[
  { name: string }
  + DetectedTrains
]]
declare_type 'DetectedTrains', [[{
  present_trains: [string],
}]]
export class FactoryHeartbeat extends Packet
  new: F '(number, string, DetectedStations, StockpileInfo) => <>', (@pc_id, @name, @stations, @stockpile) =>

spec ->
  import 'spec_macros' as $

  import 'freight.pc' as :TestPcBackend
  import 'freight.peripheral.station' as :TestStationBackend
  import 'freight.peripheral.stockpile' as :TestInventoryBackend
  import 'freight.peripheral.uplink' as :TestUplinkBackend
  import 'spec' as :describe, :it, :matchers

  import deep_eq, eq, has_fields, len from matchers

  describe 'Factory', ->
    it 'resolves label and name mismatches', ->
      CONFIG_NAME = 'config-name'
      PC_NAME = 'pc-name'
      new_name = nil

      config =
        factory:
          name: CONFIG_NAME
          network: 'mainline'
        stations: {}
      pc = Pc TestPcBackend
        name: => PC_NAME
        set_name: (name) =>
          new_name = name
      stations = {}
      stockpile = Stockpile { Inventory TestInventoryBackend! }
      uplink = Uplink TestUplinkBackend!

      Factory config, pc, stations, stockpile, uplink

      $expect_that new_name, eq CONFIG_NAME

    -- it 'responds to stockpile requests', ->
    --   sent = {}
    --   SERVER_ID = 12345
    --   idemp_tok = IdempotenceToken!
    --
    --   PC_ID = 54321
    --   PC_NAME = 'test-pc-name'
    --   config =
    --     factory:
    --       name: PC_NAME
    --       network: 'mainline'
    --     stations: {}
    --   stations =
    --     * Station TestStationBackend!
    --   pc = Pc TestPcBackend
    --     id: => PC_ID
    --     name: => PC_NAME
    --   stockpile = Stockpile
    --     * Inventory TestInventoryBackend
    --       size: => 1
    --       slot_content: (i) =>
    --         $assert_that i, eq 1
    --         count: 32, displayName: 'Stone Bricks'
    --       slot_capacity: (i) =>
    --         $assert_that i, eq 1
    --         64
    --   uplink = Uplink TestUplinkBackend
    --     receive: (_, _) =>
    --       @count ??= 1
    --       if @count == 1
    --         @count += 1
    --         return SERVER_ID, (StockpileRequest idemp_tok), StockpileRequest\protocol!
    --       nil, nil, nil
    --     send: (recipient, message, protocol) =>
    --       sent[] = :recipient, :message, :protocol
    --       true
    --   factory = Factory config, pc, stations, stockpile, uplink
    --
    --   for _ = 1, 10
    --     factory\do_network_step!
    --
    --   $expect_that sent, len eq 1
    --   $expect_that sent[1], has_fields
    --     recipient: eq SERVER_ID
    --     message: has_fields
    --       idemp_tok: eq idemp_tok
    --       info: has_fields
    --         stored_items: has_fields
    --           * has_fields
    --               item: eq 'Stone Bricks'
    --               stored: eq 32
    --     protocol: eq StockpileResponse\protocol!

    it 'responds to valid schedule requests', ->
      sent = {}
      SERVER_ID = 12345
      idemp_tok = IdempotenceToken!
      applied_schedules = {}

      STATION_NAME = 'test-station-name'
      schedule =
        cyclic: false
        entries:
          * instruction:
              id: 'create:destination'
              data: text: STATION_NAME
            conditions: {}

      PC_NAME = 'test-factory-name'
      config =
        factory:
          name: PC_NAME
          network: 'mainline'
        stations: {}
      pc = Pc TestPcBackend
        id: => PC_ID
        name: => PC_NAME
      stations =
        * Station TestStationBackend
          name: => STATION_NAME
          train_set_schedule: (schedule) =>
            applied_schedules[] = schedule
            true
      stockpile = Stockpile {}
      uplink = Uplink TestUplinkBackend
        send: (recipient, message, protocol) =>
          sent[] = :recipient, :message, :protocol
          true
        receive: (_, _) =>
          @count ??= 1
          if @count <= 1
            @count += 1
            SERVER_ID, (ScheduleRequest idemp_tok, STATION_NAME, schedule), ScheduleRequest\protocol!
          else
            nil, nil, nil
      factory = Factory config, pc, stations, stockpile, uplink

      for _ = 1, 10
        factory\do_network_step!

      $expect_that sent, deep_eq
        * recipient: SERVER_ID
          protocol: ScheduleResponse\protocol!
          message: ScheduleResponse idemp_tok, nil
      $expect_that applied_schedules, len eq 1
      $expect_that applied_schedules, deep_eq {schedule}

    it 'responds to invalid schedule requests', ->
      sent = {}
      SERVER_ID = 12345
      idemp_tok = IdempotenceToken!
      applied_schedules = {}

      STATION_NAME = 'test-station-name'
      schedule =
        cyclic: false
        entries:
          * instruction:
              id: 'create:destination'
              data: text: STATION_NAME
            conditions: {}

      FACTORY_NAME = 'test-factory-name'
      config =
        factory:
          name: FACTORY_NAME
          network: 'mainline'
        stations: {}
      pc = Pc TestPcBackend
        id: => PC_ID
        name: => FACTORY_NAME
      stations = {}
      stockpile = Stockpile
        * Inventory TestInventoryBackend
          size: => 1
          slot_content: (i) =>
            $assert_that i, eq 1
            count: 32, displayName: 'Stone Bricks'
          slot_capacity: (i) =>
            $assert_that i, eq 1
            64
      uplink = Uplink TestUplinkBackend
        send: (recipient, message, protocol) =>
          sent[] = :recipient, :message, :protocol
          true
        receive: (_, _) =>
          @count ??= 1
          if @count <= 1
            @count += 1
            SERVER_ID, (ScheduleRequest idemp_tok, STATION_NAME, schedule), ScheduleRequest\protocol!
          else
            nil, nil, nil
      factory = Factory config, pc, stations, stockpile, uplink

      for _ = 1, 10
        factory\do_network_step!

      $expect_that sent, deep_eq
        * recipient: SERVER_ID
          protocol: ScheduleResponse\protocol!
          message: ScheduleResponse idemp_tok, "no such station: #{STATION_NAME} at #{FACTORY_NAME}"
      $expect_that applied_schedules, deep_eq {}

    -- it 'responds to info requests', ->
    --   sent = {}
    --   SERVER_ID = 12345
    --   idemp_tok = IdempotenceToken!
    --
    --   PC_NAME = 'test-factory-name'
    --   config =
    --     factory:
    --       name: PC_NAME
    --       network: 'mainline'
    --     stations: {}
    --   pc = Pc TestPcBackend
    --     id: => PC_ID
    --     name: => PC_NAME
    --   stations =
    --     * Station TestStationBackend
    --         name: => 'test-station-name'
    --         train_name: =>
    --           @count ??= 1
    --           if @count == 1
    --             @count += 1
    --             'test-train-name'
    --           else
    --             nil
    --   stockpile = Stockpile
    --     * Inventory TestInventoryBackend
    --       size: => 1
    --       slot_content: (i) =>
    --         $assert_that i, eq 1
    --         count: 32, displayName: 'Stone Bricks'
    --       slot_capacity: (i) =>
    --         $assert_that i, eq 1
    --         64
    --   uplink = Uplink TestUplinkBackend
    --     receive: (_, _) =>
    --       @count ??= 1
    --       if @count <= 2
    --         @count += 1
    --         SERVER_ID, (InfoRequest idemp_tok), InfoRequest\protocol!
    --       else
    --         nil, nil, nil
    --     send: (recipient, message, protocol) =>
    --       sent[] = :recipient, :message, :protocol
    --       true
    --   factory = Factory config, pc, stations, stockpile, uplink
    --
    --   for _ = 1, 10
    --     factory\do_network_step!
    --
    --   $expect_that sent, len eq 2
    --   $expect_that sent[1], has_fields
    --     recipient: eq SERVER_ID
    --     message: has_fields
    --       idemp_tok: eq idemp_tok
    --       name: eq 'test-factory-name'
    --       station_infos: deep_eq
    --         * name: 'test-station-name'
    --           train_name: 'test-train-name'
    --       stockpile_info: has_fields
    --         stored_items: has_fields
    --           * has_fields
    --               item: eq 'Stone Bricks'
    --               stored: eq 32
    --     protocol: eq InfoResponse\protocol!
    --   $expect_that sent[2], has_fields
    --     recipient: eq SERVER_ID
    --     message: has_fields
    --       idemp_tok: eq idemp_tok
    --       name: eq 'test-factory-name'
    --       station_infos: deep_eq
    --         * name: 'test-station-name'
    --           train_name: nil
    --       stockpile_info: has_fields
    --         stored_items: has_fields
    --           * has_fields
    --               item: eq 'Stone Bricks'
    --               stored: eq 32
    --     protocol: eq InfoResponse\protocol!

    describe '\\send_heartbeat', ->
      it 'sends a heartbeat', ->
        sent = {}
        broadcasted = {}
        SERVER_ID = 12345
        PC_ID = 54321
        PC_NAME = 'test-factory-name'

        config =
          factory:
            name: PC_NAME
            network: 'mainline'
          stations:
            * name: 'known_station'
              network: 'some-network'
              type: 'inbound'
              handles: 'minecraft:stone_bricks'
        pc = Pc TestPcBackend
          id: => PC_ID
          name: => PC_NAME
        stations =
          * Station TestStationBackend
              name: => 'known_station'
              train_name: => 'train_1'
          * Station TestStationBackend
              name: => 'unknown_station'
              train_name: => 'train_2'
        stockpile = Stockpile
          * Inventory TestInventoryBackend
            size: => 1
            list: =>
              slot =
                name: 'minecraft:stone_bricks'
                count: 32
              {slot}
            slot_capacity: (i) =>
              $assert_that i, eq 1
              64
        uplink = Uplink TestUplinkBackend
          send: (recipient, message, protocol) =>
            sent[] = :recipient, :message, :protocol
            true
          broadcast: (message, protocol) =>
            broadcasted[] = :message, :protocol
        with Factory config, pc, stations, stockpile, uplink
          \send_heartbeat!

        $expect_that sent, deep_eq {}

        $expect_that broadcasted, len eq 1
        $expect_that broadcasted[1], has_fields
          protocol: eq FactoryHeartbeat\protocol!
          message: do
            stations =
              known:
                * name: 'known_station'
                  network: 'some-network'
                  type: 'inbound'
                  handles: 'minecraft:stone_bricks'
                  present_trains:
                    * 'train_1'
              unknown:
                * name: 'unknown_station'
                  present_trains:
                    * 'train_2'

            stockpile_info =
              stored_items:
                -- TODO(kcza): rename this field to 'name'
                * item: 'minecraft:stone_bricks'
                  stored: 32
              estimated_capacity: 64
            deep_eq FactoryHeartbeat PC_ID, PC_NAME, stations, stockpile_info
